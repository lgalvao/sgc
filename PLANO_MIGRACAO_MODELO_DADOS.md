# Plano de Migra√ß√£o do Modelo de Dados SGC - Guia para Agente IA

**Data:** 11 de Dezembro de 2024  
**Objetivo:** Migrar do esquema PostgreSQL/H2 atual para o novo esquema Oracle.

**ü§ñ ATEN√á√ÉO AGENTE:** Este documento √© seu guia de execu√ß√£o. Cada se√ß√£o cont√©m:

- ‚úÖ Verifica√ß√µes necess√°rias antes de prosseguir
- üìã Ordem de execu√ß√£o (depend√™ncias entre tarefas)
- ‚ö†Ô∏è Pontos cr√≠ticos que podem quebrar o sistema
- üîç Como validar se a mudan√ßa foi bem-sucedida

---

## 1. VIS√ÉO GERAL DA MIGRA√á√ÉO

**Mudan√ßas Principais:**

1. PostgreSQL/H2 ‚Üí Oracle 12c+ (usando perfil `prod`)
2. VIEWs externas: `USUARIO`, `UNIDADE`, `USUARIO_PERFIL_UNIDADE` (somente leitura)
3. Chave composta em `UNIDADE_PROCESSO`
4. Invers√£o de relacionamento `MAPA` ‚Üî `SUBPROCESSO`

**Arquivos de Refer√™ncia:**

- DDL Tabelas: `backend/sql/script_ddl_tabelas_sgc.sql`
- DDL Views: `backend/sql/script_ddl_views_sgc.sql`
- Perfil Oracle: `backend/src/main/resources/application-prod.yml`

---

## 2. MUDAN√áAS POR TABELA

### 2.1. PROCESSO

**Status:** Mudan√ßas m√≠nimas

| Campo | Esquema Atual | Novo Esquema | A√ß√£o |
|-------|---------------|--------------|------|
| `codigo` | `BIGINT GENERATED BY DEFAULT AS IDENTITY` | `NUMBER NOT NULL` | Alterar tipo, usar IDENTITY Oracle |
| `data_limite` | `TIMESTAMP(6)` | `DATE` | Alterar tipo (DATE Oracle inclui hora, minuto, segundo) |
| Demais campos | Mantidos | Mantidos | Sem altera√ß√£o |

**Observa√ß√µes:**

- Oracle usa `NUMBER` em vez de `BIGINT`
- `data_limite`: `TIMESTAMP(6)` ‚Üí `DATE` (Oracle DATE tem precis√£o de segundo, perde microssegundos)
- Precisa criar SEQUENCE manualmente no Oracle

---

### 2.2. UNIDADE_PROCESSO

**Status:** MUDAN√áA CR√çTICA - Estrutura completamente alterada

#### Esquema Atual (PostgreSQL/H2)

```sql
CREATE TABLE unidade_processo (
    codigo                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    processo_codigo         BIGINT,
    unidade_codigo          BIGINT,
    titular_titulo          VARCHAR(255),
    sigla                   VARCHAR(20),
    situacao                VARCHAR(20),
    tipo                    VARCHAR(20),
    nome                    VARCHAR(255),
    unidade_superior_codigo BIGINT,
    -- FKs para processo e unidade
);
```

#### Novo Esquema (Oracle)

```sql
CREATE TABLE UNIDADE_PROCESSO (
    processo_codigo         NUMBER NOT NULL,        -- Agora PK composta
    unidade_codigo          NUMBER NOT NULL,        -- Agora PK composta
    nome                    VARCHAR2(255),
    sigla                   VARCHAR2(20),
    matricula_titular       VARCHAR2(8),           -- NOVO CAMPO
    titulo_titular          VARCHAR2(12),          -- Renomeado e redimensionado
    data_inicio_titularidade DATE,                 -- NOVO CAMPO
    tipo                    VARCHAR2(20),
    situacao                VARCHAR2(20),
    unidade_superior_codigo NUMBER,
    PRIMARY KEY (processo_codigo, unidade_codigo)  -- PK COMPOSTA
);
```

**Mudan√ßas Cr√≠ticas:**

1. **PK mudou:** De `codigo` autoincrementado para PK composta `(processo_codigo, unidade_codigo)`
2. **Novos campos:** `matricula_titular`, `data_inicio_titularidade`
3. **Campo renomeado:** `titular_titulo` ‚Üí `titulo_titular` (tamanho: 255 ‚Üí 12)
4. **Sem ID pr√≥prio:** Tabela agora √© snapshot puro, n√£o tem identidade pr√≥pria

**Impacto no C√≥digo Java:**

- **Entidade `UnidadeProcesso`** precisa ser completamente reescrita
- Usar `@EmbeddedId` ou `@IdClass` para PK composta
- Remover `extends EntidadeBase` (n√£o tem mais ID √∫nico)
- Ajustar todos os reposit√≥rios e queries que usam esta tabela

---

### 2.3. SUBPROCESSO

**Status:** Mudan√ßa cr√≠tica na FK

#### Mudan√ßa Principal

```sql
-- Atual
CONSTRAINT fk_subprocesso_processo FOREIGN KEY (processo_codigo) 
    REFERENCES processo(codigo)
CONSTRAINT fk_subprocesso_unidade FOREIGN KEY (unidade_codigo) 
    REFERENCES unidade(codigo)

-- Novo
CONSTRAINT fk_subprocesso_up FOREIGN KEY (processo_codigo, unidade_codigo) 
    REFERENCES UNIDADE_PROCESSO(processo_codigo, unidade_codigo)
```

| Campo | Atual | Novo | A√ß√£o |
|-------|-------|------|------|
| `codigo` | `BIGINT` | `NUMBER` | Alterar tipo |
| `data_limite_etapa1` | `TIMESTAMP(6)` | `DATE` | Alterar tipo (perde precis√£o de microssegundos) |
| `data_limite_etapa2` | `TIMESTAMP(6)` | `DATE` | Alterar tipo (perde precis√£o de microssegundos) |
| `situacao_id` | `VARCHAR(50)` | `situacao VARCHAR2(50)` | Renomear coluna |

**Impacto no C√≥digo Java:**

- FK agora aponta para `UNIDADE_PROCESSO` com chave composta
- JPA precisa de `@JoinColumns` com m√∫ltiplas colunas:

```java
@ManyToOne
@JoinColumns({
    @JoinColumn(name = "processo_codigo", referencedColumnName = "processo_codigo"),
    @JoinColumn(name = "unidade_codigo", referencedColumnName = "unidade_codigo")
})
private UnidadeProcesso unidadeProcesso;
```

- Remover FKs separadas para `Processo` e `Unidade`
- Renomear campo `situacao` (coluna `situacao_id` ‚Üí `situacao`)

---

### 2.4. MAPA

**Status:** Mudan√ßas estruturais significativas

| Campo | Atual | Novo | A√ß√£o |
|-------|-------|------|------|
| `codigo` | `BIGINT` | `NUMBER` | Alterar tipo |
| `unidade_codigo` | FK para UNIDADE | **REMOVIDO** | Remover do MAPA |
| `subprocesso_codigo` | N√£o existe | `NUMBER NOT NULL` (FK) | **ADICIONAR** |
| `sugestoes` | `TEXT` | `VARCHAR2(1000)` | Manter tipo (j√° era VARCHAR2) |

**Mudan√ßa Conceitual Cr√≠tica:**

- **Antes:** `MAPA` tinha FK direta para `UNIDADE`
- **Agora:** `MAPA` tem FK para `SUBPROCESSO`
- **Antes:** `SUBPROCESSO` tinha FK para `MAPA` (opcional)
- **Agora:** `MAPA` obrigatoriamente pertence a `SUBPROCESSO`

**Campo `sugestoes`:**

- Campo √∫nico para armazenar sugest√µes apresentadas durante valida√ß√£o
- Tipo: `VARCHAR2(1000)`

**Impacto no C√≥digo Java:**

- Inverter relacionamento: Mapa n√£o conhece Unidade, conhece Subprocesso
- Campo `sugestoes` permanece como `String` (limite 1000 caracteres)
- Atualizar toda l√≥gica de neg√≥cio que acessa mapa.unidade

---

### 2.5. UNIDADE

**Status:** Tabela REMOVIDA do SGC, substitu√≠da por VIEW

**Situa√ß√£o Atual:**

```sql
CREATE TABLE unidade (
    codigo BIGINT PRIMARY KEY,
    nome VARCHAR(255),
    sigla VARCHAR(20),
    titular_titulo VARCHAR(255),
    tipo VARCHAR(20),
    situacao VARCHAR(20),
    unidade_superior_codigo BIGINT,
    mapa_vigente_codigo BIGINT,
    data_vigencia_mapa_atual TIMESTAMP(6)
);
```

**Novo Modelo:**

- **Tabela f√≠sica REMOVIDA** do esquema SGC
- Substitu√≠da por **VIEW externa** `VW_UNIDADE` (do SGRH)
- Nova tabela `UNIDADE_MAPA` criada para relacionamento 1:1 com MAPA

```sql
CREATE TABLE UNIDADE_MAPA (
    unidade_codigo      NUMBER NOT NULL PRIMARY KEY,
    mapa_vigente_codigo NUMBER NOT NULL,
    CONSTRAINT fk_unidade_mapa_mapa FOREIGN KEY (mapa_vigente_codigo) REFERENCES MAPA(codigo)
);
```

**Impacto Cr√≠tico no C√≥digo Java:**

1. **Entidade `Unidade`:**
   - Continua como `@Entity` mapeando a VIEW `VW_UNIDADE`
   - Adicionar `@Immutable` (VIEW √© somente leitura)
   - Usar `@Table(name = "VW_UNIDADE")`
   - **Novo campo:** `matriculaTitular` (VARCHAR2(8))
   - **Novo campo:** `dataInicioTitularidade` (DATE)
   - **Novo tipo:** `SEM_EQUIPE` (adicionar ao enum `TipoUnidade`)
   - **Novo tipo:** `RAIZ` (adicionar ao enum `TipoUnidade`)
   - Remover campos `mapaVigente` e `dataVigenciaMapa` da entidade
   - **Manter relacionamentos:** JPA permite `@ManyToOne` para entidades imut√°veis

2. **Nova Entidade `UnidadeMapa`:**
   - Criar para representar o relacionamento Unidade ‚Üî Mapa vigente
   - PK: `unidade_codigo`
   - FK: `mapa_vigente_codigo`

3. **Reposit√≥rio `UnidadeRepo`:**
   - **Continua usando `JpaRepository`** normalmente
   - Consulta a VIEW `VW_UNIDADE` transparentemente
   - Somente LEITURA (m√©todos save/update/delete n√£o funcionar√£o)

4. **Todas as FKs para UNIDADE:**
   - Mudam de FK real para "FK l√≥gica/impl√≠cita"
   - Sem constraint f√≠sico no banco
   - **JPA continua funcionando:** `@ManyToOne` e `@JoinColumn` mantidos
   - Valida√ß√£o de integridade deve ser feita na aplica√ß√£o

5. **Enum `TipoUnidade`:**
   - **Adicionar:** `SEM_EQUIPE` (unidades sem equipe pr√≥pria)
   - **Adicionar:** `RAIZ` (unidade raiz administrativa c√≥digo 1)
   - Manter: `OPERACIONAL`, `INTERMEDIARIA`, `INTEROPERACIONAL`

---

### 2.6. USUARIO e USUARIO_PERFIL

**Status:** Tabelas REMOVIDAS, substitu√≠das por VIEW

NOTA: Pode continuar como Entity sim, mesmo sendo view, mas deve ser somente-leitura.

**Situa√ß√£o Atual:**

```sql
CREATE TABLE usuario (
    titulo_eleitoral VARCHAR(255) PRIMARY KEY,
    nome VARCHAR(255),
    email VARCHAR(255),
    ramal VARCHAR(20),
    unidade_codigo BIGINT
);

CREATE TABLE usuario_perfil (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    usuario_titulo_eleitoral VARCHAR(255),
    unidade_codigo BIGINT,
    perfil VARCHAR(255)
);
```

**Novo Modelo:**

- **Tabelas f√≠sicas REMOVIDAS** do esquema SGC
- Substitu√≠das por **VIEW externa** `VW_USUARIO` (do SGRH)
- VIEW cont√©m informa√ß√µes completas do usu√°rio

### 5.1. VW_USUARIO

**Campos da VIEW:**

- `titulo` - VARCHAR2(12) (PK - t√≠tulo eleitoral)
- `matricula` - VARCHAR2(8) (matr√≠cula do servidor)
- `nome` - VARCHAR2 (nome completo)
- `email` - VARCHAR2 (e-mail)
- `ramal` - VARCHAR2 (ramal telef√¥nico)
- `unidade_lot_codigo` - NUMBER (unidade de lota√ß√£o)
- `unidade_comp_codigo` - NUMBER (unidade de compet√™ncia)

**Fonte:** Integra√ß√£o com `SRH2.SERVIDOR`, `SRH2.LOTACAO`, `SRH2.LOT_RAMAIS_SERVIDORES`

**Diferen√ßas do modelo atual:**

- **Novo campo:** `matricula`
- **Novo campo:** `unidade_comp_codigo` (unidade ajustada para compet√™ncia)
- **Campo renomeado:** `unidade_codigo` ‚Üí `unidade_lot_codigo`

**Fonte de Dados:**

- Perfis ADMIN v√™m da tabela `ADMINISTRADOR` do SGC
- Outros perfis (GESTOR, CHEFE, SERVIDOR) v√™m do SGRH ou outras fontes
- VIEW consolida todas as atribui√ß√µes de perfil

**Impacto Cr√≠tico no C√≥digo Java:**

1. **Entidade `Usuario`:**
   - Continua como `@Entity` mapeando a VIEW `VW_USUARIO`
   - Adicionar `@Immutable` (VIEW √© somente leitura)
   - Usar `@Table(name = "VW_USUARIO")`
   - Campo PK: `titulo` (VARCHAR2(12))
   - **Novo campo:** `matricula` (VARCHAR2(8))
   - **Novo campo:** `unidadeCompCodigo` (NUMBER - unidade de compet√™ncia)
   - **Renomear:** `unidadeCodigo` ‚Üí `unidadeLotCodigo` (lota√ß√£o)
   - Remover relacionamento `@OneToMany` com `UsuarioPerfil`
   - **Manter relacionamentos:** `@ManyToOne` com Unidade continua funcionando

2. **Entidade `UsuarioPerfil`:**
   - **CONVERTER para entidade somente-leitura** (n√£o deletar!)
   - Mapear VIEW `VW_USUARIO_PERFIL_UNIDADE` com `@Immutable`
   - Campos: `usuarioTitulo` (VARCHAR2(12)), `perfil` (String), `unidadeCodigo` (NUMBER)
   - **Importante:** Perfis s√£o derivados automaticamente, exceto ADMIN

3. **Autentica√ß√£o e Autoriza√ß√£o:**
   - **Sistema de perfis mant√©m estrutura similar**
   - `Usuario` **pode continuar implementando `UserDetails`**
   - Adaptar m√©todo `getTodasAtribuicoes()` para consultar `VW_USUARIO_PERFIL_UNIDADE`
   - **Perfis autom√°ticos:**
     - ADMIN: gerenciado via tabela `ADMINISTRADOR`
     - GESTOR: autom√°tico para respons√°veis de unidades INTERMEDIARIA/INTEROPERACIONAL
     - CHEFE: autom√°tico para respons√°veis de unidades INTEROPERACIONAL/OPERACIONAL
     - SERVIDOR: autom√°tico para todos os usu√°rios

4. **Reposit√≥rio `UsuarioRepo`:**
   - **Continua usando `JpaRepository`** normalmente
   - Somente LEITURA (m√©todos save/update/delete n√£o funcionar√£o)

5. **Novo Reposit√≥rio `AdministradorRepo`:**
   - Criar para gerenciar perfis ADMIN
   - √önico perfil gerenciado diretamente pelo SGC
   - Suporta INSERT/UPDATE/DELETE (√© tabela f√≠sica)

---

### 2.7. ADMINISTRADOR e VW_USUARIO_PERFIL

**Status:** Tabela NOVA + VIEW para perfis

```sql
CREATE TABLE ADMINISTRADOR (
    usuario_titulo VARCHAR2(12) NOT NULL PRIMARY KEY
);
```

**Nova VIEW:** `VW_USUARIO_PERFIL` (do SGRH)

- Combina dados de m√∫ltiplas fontes para determinar perfis dos usu√°rios
- Inclui administradores da tabela `ADMINISTRADOR` do SGC
- Possivelmente inclui outros perfis vindos do SGRH

**Impacto:**

- **Criar nova entidade `Administrador`**
- PK: `usuario_titulo` (FK l√≥gica para `VW_USUARIO.titulo`)
- Usado para **alimentar** a VIEW `VW_USUARIO_PERFIL` com perfis ADMIN
- **Criar nova entidade `UsuarioPerfil`** (ou renomear a existente) para mapear `VW_USUARIO_PERFIL`
- `UsuarioPerfil` vira entidade **somente-leitura** (VIEW) com `@Immutable`

**Diferen√ßa do modelo anterior:**

- **Antes:** `USUARIO_PERFIL` era tabela f√≠sica gerenciada pelo SGC
- **Agora:** `VW_USUARIO_PERFIL` √© VIEW que consolida perfis de v√°rias fontes
- `ADMINISTRADOR` √© a √∫nica tabela de perfis gerenciada pelo SGC
- Demais perfis v√™m de outras fontes via VIEW

---

### 2.8. ALERTA e ALERTA_USUARIO

**Status:** Mudan√ßas nos tipos e tamanhos

#### ALERTA

| Campo | Atual | Novo | A√ß√£o |
|-------|-------|------|------|
| `codigo` | `BIGINT` | `NUMBER` | Alterar tipo |
| `usuario_destino_titulo` | `VARCHAR(255)` | `VARCHAR2(12)` | Reduzir tamanho |

**FKs:**

- FKs para `unidade_destino_codigo` e `unidade_origem_codigo` viram l√≥gicas (sem constraint)
- FK para `usuario_destino_titulo` vira l√≥gica (aponta para VIEW)

#### ALERTA_USUARIO

| Campo | Atual | Novo | A√ß√£o |
|-------|-------|------|------|
| `usuario_titulo_eleitoral` | `VARCHAR(255)` | `usuario_titulo VARCHAR2(12)` | Renomear e reduzir |

**Impacto no C√≥digo Java:**

- Alterar tamanhos dos campos `String`
- FKs para Usuario e Unidade viram l√≥gicas (sem constraint f√≠sico)
- Renomear campo `usuarioTituloEleitoral` ‚Üí `usuarioTitulo`

---

### 2.9. ANALISE

**Status:** Mudan√ßas nos campos

| Campo | Atual | Novo | A√ß√£o |
|-------|-------|------|------|
| `codigo` | `BIGINT` | `NUMBER` | Alterar tipo |
| `analista_usuario_titulo` | `VARCHAR(50)` | `usuario_titulo VARCHAR2(12)` | Renomear e reduzir |
| `unidade_sigla` | `VARCHAR(30)` | `unidade_codigo NUMBER` | **Mudan√ßa conceitual** |

**Mudan√ßa Cr√≠tica:**

- **Antes:** Armazena `unidade_sigla` (String)
- **Agora:** Armazena `unidade_codigo` (Number)

**Impacto no C√≥digo Java:**

- Alterar tipo de `String unidadeSigla` para `Long unidadeCodigo`
- FK l√≥gica para `VW_UNIDADE.codigo`
- Renomear `analistaUsuarioTitulo` ‚Üí `usuarioTitulo`

---

### 2.10. ATRIBUICAO_TEMPORARIA

**Status:** Mudan√ßas significativas

| Campo | Atual | Novo | A√ß√£o |
|-------|-------|------|------|
| `codigo` | `BIGINT` | `NUMBER` | Alterar tipo |
| `usuario_titulo` | `VARCHAR(255)` | `VARCHAR2(12)` | Reduzir tamanho |
| `usuario_matricula` | N√£o existe | `VARCHAR2(8)` | **ADICIONAR** |
| `perfil` | `VARCHAR(255)` | **REMOVIDO** | **DELETAR** |
| `data_inicio` | `TIMESTAMP(6)` | `DATE` | Alterar tipo (perde microssegundos) |
| `data_termino` | `TIMESTAMP(6)` | `DATE` | Alterar tipo (perde microssegundos) |

**Impacto no C√≥digo Java:**

- Adicionar campo `usuarioMatricula`
- **Remover campo `perfil`** da entidade
- Se a l√≥gica de perfis tempor√°rios for necess√°ria, reimplementar de outra forma
- FK l√≥gica para `VW_USUARIO.titulo`
- **Importante:** `LocalDateTime` continua adequado para campos DATE do Oracle (inclui data e hora)

---

### 2.11. ATIVIDADE, COMPETENCIA, COMPETENCIA_ATIVIDADE, CONHECIMENTO

**Status:** Mudan√ßas m√≠nimas (apenas tipos)

| Tabela | Campo | Atual | Novo |
|--------|-------|-------|------|
| ATIVIDADE | `codigo` | `BIGINT` | `NUMBER` |
| ATIVIDADE | `mapa_codigo` | `BIGINT` | `NUMBER` |
| COMPETENCIA | `codigo` | `BIGINT` | `NUMBER` |
| COMPETENCIA | `mapa_codigo` | `BIGINT` | `NUMBER` |
| CONHECIMENTO | `codigo` | `BIGINT` | `NUMBER` |
| CONHECIMENTO | `atividade_codigo` | `BIGINT` | `NUMBER` |

**Impacto:** Apenas ajuste de tipos de dados Java (`Long` continua adequado para `NUMBER`)

---

### 2.12. MOVIMENTACAO e NOTIFICACAO

**Status:** Mudan√ßas nos tipos

| Campo | Atual | Novo |
|-------|-------|------|
| `codigo` | `BIGINT` | `NUMBER` |
| `unidade_origem_codigo` | FK real | FK l√≥gica |
| `unidade_destino_codigo` | FK real | FK l√≥gica |
| `usuario_codigo` | `VARCHAR(255)` FK real | `usuario_titulo VARCHAR2(12)` FK l√≥gica |

**Impacto no C√≥digo Java:**

- FKs viram l√≥gicas (sem constraint)
- Valida√ß√µes devem ser feitas na aplica√ß√£o
- Campo `usuarioCodigo` ‚Üí `usuarioTitulo` (renomear)

---

### 2.13. PARAMETRO

**Status:** Mudan√ßas m√≠nimas

| Campo | Atual | Novo |
|-------|-------|------|
| `codigo` | `BIGINT` | `NUMBER` |
| Demais | Mantidos | Tamanhos mantidos |

**Impacto:** Apenas ajuste de tipo

---

### 2.14. VINCULACAO_UNIDADE ‚Üí VW_VINCULACAO_UNIDADE

**Status:** Tabela f√≠sica REMOVIDA, substitu√≠da por VIEW

**Situa√ß√£o Atual:**
```sql
CREATE TABLE vinculacao_unidade (
    codigo BIGINT PRIMARY KEY,
    unidade_anterior_codigo BIGINT,
    unidade_atual_codigo BIGINT
);
```

**Novo Modelo:**
- **Tabela f√≠sica REMOVIDA** do esquema SGC
- Substitu√≠da por **VIEW** `VW_VINCULACAO_UNIDADE` (do SGRH)

**Campos da VIEW:**
- `unidade_atual_codigo` - NUMBER (c√≥digo da unidade atual)
- `unidade_anterior_codigo` - NUMBER (c√≥digo da unidade anterior imediata)
- `demais_unidades_historicas` - VARCHAR2 (lista de unidades hist√≥ricas separadas por v√≠rgula)

**Fonte:** `SRH2.UNIDADE_TSE` com hierarquia hist√≥rica (campo `COD_UNID_TSE_ANT`)

**Impacto no C√≥digo Java:**

**Op√ß√£o 1: Mapear a VIEW (Recomendado)**
```java
@Entity
@Immutable
@Table(name = "VW_VINCULACAO_UNIDADE", schema = "sgc")
@IdClass(VinculacaoUnidadeId.class)  // PK composta
public class VinculacaoUnidade {
    
    @Id
    @Column(name = "unidade_atual_codigo")
    private Long unidadeAtualCodigo;
    
    @Id
    @Column(name = "unidade_anterior_codigo")
    private Long unidadeAnteriorCodigo;
    
    @Column(name = "demais_unidades_historicas")
    private String demaisUnidadesHistoricas;
    
    // FKs l√≥gicas para VW_UNIDADE (sem @ManyToOne)
}
```

**Op√ß√£o 2: Deletar a entidade (se n√£o for usada)**
- Verificar se h√° c√≥digo que usa `VinculacaoUnidade`
- Se n√£o houver uso, simplesmente deletar a entidade e reposit√≥rio

**Valida√ß√£o:**
```java
@Test
void deveConsultarVinculacaoUnidade() {
    List<VinculacaoUnidade> vinculos = vinculacaoUnidadeRepo.findAll();
    // Verificar que dados v√™m da VIEW
}
```

**‚ö†Ô∏è Aten√ß√£o:** Esta VIEW √© somente leitura. N√£o h√° como criar/atualizar v√≠nculos no SGC. O hist√≥rico √© gerenciado pelo SGRH.

---

### 2.15. DIAGN√ìSTICO, AVALIACAO_SERVIDOR, OCUPACAO_CRITICA

**Status:** N√£o documentadas no novo DDL

Estas tabelas **existem no esquema atual** mas **n√£o aparecem no novo DDL Oracle**.

**A√ß√£o necess√°ria:**

- Verificar se o m√≥dulo de Diagn√≥stico ser√° mantido
- Se sim, adicionar as tabelas ao DDL Oracle
- Se n√£o, remover as entidades e c√≥digo relacionado

---

## 3. MUDAN√áAS NOS TIPOS DE DADOS

### 3.1. PostgreSQL ‚Üí Oracle

| Tipo PostgreSQL | Tipo Oracle | Observa√ß√µes |
|----------------|-------------|-------------|
| `BIGINT` | `NUMBER` | Oracle NUMBER √© flex√≠vel |
| `BIGINT GENERATED BY DEFAULT AS IDENTITY` | `NUMBER GENERATED BY DEFAULT AS IDENTITY` | Oracle 12c+ suporta IDENTITY nativo |
| `VARCHAR(n)` | `VARCHAR2(n)` | Oracle usa VARCHAR2 |
| `TEXT` | `VARCHAR2(4000)` ou `CLOB` | Limites diferentes |
| `TIMESTAMP(6)` | `TIMESTAMP` ou `DATE` | TIMESTAMP mant√©m precis√£o; DATE tem precis√£o de segundo |
| `BOOLEAN` | N√£o existe nativamente | Usar `NUMBER(1)` ou `VARCHAR2(1)` |

**Nota sobre DATE no Oracle:**

- `DATE` do Oracle **inclui data E hora** (at√© segundos)
- Precis√£o: ano, m√™s, dia, hora, minuto, segundo
- `TIMESTAMP(6)` ‚Üí `DATE`: Perde precis√£o de fra√ß√µes de segundo (microssegundos)
- N√£o h√° perda de hora/minuto/segundo, apenas de fra√ß√µes de segundo

---

## 4. GERA√á√ÉO DE CHAVES NO ORACLE

O DDL usa **IDENTITY columns** com sintaxe expl√≠cita:

```sql
-- Sintaxe Oracle IDENTITY expl√≠cita
CREATE TABLE PROCESSO (
    codigo NUMBER GENERATED ALWAYS AS IDENTITY START WITH 1 INCREMENT BY 1 NOT NULL,
    ...
);
```

**Caracter√≠sticas:**

- `GENERATED ALWAYS AS IDENTITY`: Sequence gerenciada automaticamente pelo Oracle
- `START WITH 1 INCREMENT BY 1`: Inicia em 1 e incrementa de 1 em 1
- Oracle 12c+ suporta esta sintaxe nativamente

**Impacto no JPA:**

- **NENHUMA MUDAN√áA NECESS√ÅRIA** nas entidades
- `@GeneratedValue(strategy = GenerationType.IDENTITY)` funciona perfeitamente
- Oracle gerencia automaticamente a sequence interna
- N√£o precisa criar ou gerenciar sequences manualmente

**Observa√ß√£o:** Requer Oracle 12c ou superior.

---

## 5. VIEWS EXTERNAS (SGRH)

O novo modelo depende de **VIEWS** que integram dados do SGRH com o SGC:

### 5.1. VW_USUARIO

**Campos da VIEW:**

- `titulo` - VARCHAR2(12) (PK - t√≠tulo eleitoral)
- `matricula` - VARCHAR2(8) (matr√≠cula do servidor)
- `nome` - VARCHAR2 (nome completo)
- `email` - VARCHAR2 (e-mail)
- `ramal` - VARCHAR2 (ramal telef√¥nico)
- `unidade_lot_codigo` - NUMBER (unidade de lota√ß√£o)
- `unidade_comp_codigo` - NUMBER (unidade de compet√™ncia)

**Fonte:** Integra√ß√£o com `SRH2.SERVIDOR`, `SRH2.LOTACAO`, `SRH2.LOT_RAMAIS_SERVIDORES`

**Diferen√ßas do modelo atual:**

- **Novo campo:** `matricula`
- **Novo campo:** `unidade_comp_codigo` (unidade ajustada para compet√™ncia)
- **Campo renomeado:** `unidade_codigo` ‚Üí `unidade_lot_codigo`

### 5.2. VW_UNIDADE

**Campos da VIEW:**

- `codigo` - NUMBER (PK - c√≥digo da unidade)
- `nome` - VARCHAR2 (nome da unidade)
- `sigla` - VARCHAR2 (sigla)
- `matricula_titular` - VARCHAR2(8) (matr√≠cula do titular)
- `titulo_titular` - VARCHAR2(12) (t√≠tulo eleitoral do titular)
- `data_inicio_titularidade` - DATE (data de in√≠cio como titular)
- `tipo` - VARCHAR2(20) (OPERACIONAL, INTERMEDIARIA, INTEROPERACIONAL, SEM EQUIPE, RAIZ)
- `situacao` - VARCHAR2(20) (ATIVA, INATIVA)
- `unidade_superior_codigo` - NUMBER (c√≥digo da unidade superior)

**Fonte:** Integra√ß√£o com `SRH2.UNIDADE_TSE`, `SRH2.LOTACAO`, `SRH2.QFC_OCUP_COM`, `SRH2.QFC_VAGAS_COM`

**Diferen√ßas do modelo atual:**

- **Novo campo:** `matricula_titular`
- **Novo campo:** `data_inicio_titularidade`
- **Novo tipo:** `SEM EQUIPE` (unidade sem equipe pr√≥pria)
- **Novo tipo:** `RAIZ` (unidade raiz administrativa com c√≥digo 1)
- **Removido:** `mapa_vigente_codigo`, `data_vigencia_mapa_atual`

**A√ß√£o Necess√°ria:**

- ‚úÖ **DDL das VIEWS j√° dispon√≠vel em:** `backend/sql/script_ddl_views_sgc.sql`
- ‚¨ú Validar permiss√µes necess√°rias nos schemas `SRH2` e `CORAU`
- ‚¨ú Testar execu√ß√£o das VIEWs no ambiente de desenvolvimento
- ‚¨ú Validar se os dados retornados pelas VIEWs est√£o corretos
- ‚¨ú Entender regras de neg√≥cio espec√≠ficas:
  - C√°lculo de `tipo` de unidade (operacional, intermedi√°ria, etc.)
  - L√≥gica de `unidade_comp_codigo` vs `unidade_lot_codigo`
  - Deriva√ß√£o autom√°tica de perfis GESTOR e CHEFE

---

## 6. PLANO DE MIGRA√á√ÉO

### Fase 1: Prepara√ß√£o

1. ‚úÖ Adicionar driver Oracle JDBC ao `build.gradle.kts`
2. ‚úÖ Criar perfil Spring `prod` com configura√ß√£o Oracle
3. ‚úÖ DDL das VIEWS obtido: `backend/sql/script_ddl_views_sgc.sql`
4. ‚¨ú Criar esquema Oracle de desenvolvimento (verificar vers√£o 12c+)
5. ‚¨ú Executar DDL Oracle (tabelas + views)
6. ‚¨ú Validar permiss√µes nos schemas SRH2 e CORAU
7. ‚¨ú Testar VIEWs e validar dados retornados

### Fase 2: Ajustes de Entidades

1. ‚¨ú `EntidadeBase` - Verificar compatibilidade (IDENTITY deve funcionar sem mudan√ßas)
2. ‚¨ú `Unidade` - Mapear VIEW com `@Immutable`, adicionar campos `matriculaTitular`, `dataInicioTitularidade`
3. ‚¨ú `TipoUnidade` - Adicionar enums `SEM_EQUIPE` e `RAIZ`
4. ‚¨ú `Usuario` - Mapear VIEW com `@Immutable`, adicionar campo `matricula`, `unidadeCompCodigo`
5. ‚¨ú `UsuarioPerfil` - Converter para VIEW `VW_USUARIO_PERFIL_UNIDADE` com `@Immutable`
6. ‚¨ú Criar entidade `UnidadeMapa`
7. ‚¨ú Criar entidade `Administrador` (tabela f√≠sica para perfis ADMIN)
8. ‚¨ú Criar reposit√≥rio `AdministradorRepo`
9. ‚¨ú Reescrever `UnidadeProcesso` com PK composta (`@EmbeddedId` ou `@IdClass`)
10. ‚¨ú Ajustar `Subprocesso` (FK composta para UnidadeProcesso com `@JoinColumns`)
11. ‚¨ú Ajustar `Mapa` (inverter relacionamento com Unidade/Subprocesso, remover campo `sugestoesApresentadas`)
12. ‚¨ú Ajustar `Analise` (unidade_sigla ‚Üí unidade_codigo)
13. ‚¨ú Ajustar `AtribuicaoTemporaria` (remover perfil, adicionar matricula)
14. ‚¨ú Ajustar `Movimentacao` (renomear `usuarioCodigo` ‚Üí `usuarioTitulo`)
15. ‚¨ú Ajustar todos os campos String com tamanhos reduzidos
16. ‚¨ú Ajustar campos TIMESTAMP ‚Üí DATE onde aplic√°vel
17. ‚¨ú `VinculacaoUnidade` - Mapear VIEW `VW_VINCULACAO_UNIDADE` com `@Immutable` (ou deletar se n√£o usada)
18. ‚¨ú Decidir sobre m√≥dulo Diagn√≥stico

### Fase 3: Reposit√≥rios e Queries

1. ‚¨ú Atualizar todos os `@Query` para sintaxe Oracle (se houver diferen√ßas)
2. ‚¨ú Revisar queries nativas (PostgreSQL ‚Üí Oracle)
3. ‚¨ú `UnidadeRepo` - Manter como est√° (JPA funciona com VIEWs)
4. ‚¨ú `UsuarioRepo` - Manter como est√° (JPA funciona com VIEWs)
5. ‚¨ú `UsuarioPerfilRepo` - Ajustar para VIEW (somente leitura)
6. ‚¨ú Criar `AdministradorRepo` - Gerenciar perfis ADMIN (tabela f√≠sica)
7. ‚¨ú Ajustar queries que usam `UnidadeProcesso.codigo` (n√£o existe mais)
8. ‚¨ú Manter `@ManyToOne` para Unidade/Usuario (JPA permite com entidades imut√°veis)

### Fase 4: L√≥gica de Neg√≥cio

1. ‚¨ú Ajustar sistema de perfis para usar `VW_USUARIO_PERFIL_UNIDADE`
2. ‚¨ú Implementar CRUD de administradores via tabela `ADMINISTRADOR`
3. ‚¨ú Ajustar `Usuario.getTodasAtribuicoes()` para consultar VIEW
4. ‚¨ú **Revisar l√≥gica de perfis autom√°ticos:** GESTOR, CHEFE, SERVIDOR s√£o derivados
5. ‚¨ú Revisar l√≥gica de autentica√ß√£o/autoriza√ß√£o
6. ‚¨ú Ajustar c√≥digo que acessa `mapa.unidade` (agora via subprocesso)
7. ‚¨ú Ajustar l√≥gica de unidade de compet√™ncia (`unidadeCompCodigo`) vs lota√ß√£o
8. ‚¨ú Revisar todas as valida√ß√µes de FK l√≥gicas
9. ‚¨ú Validar se precis√£o de segundo (DATE) √© suficiente vs microssegundos (TIMESTAMP)

### Fase 5: Testes

1. ‚¨ú Atualizar testes unit√°rios
2. ‚¨ú Atualizar testes de integra√ß√£o
3. ‚¨ú Criar schema de testes Oracle (ou usar H2 em modo Oracle)
4. ‚¨ú Executar suite completa de testes
5. ‚¨ú Testes E2E com banco Oracle

### Fase 6: Migra√ß√£o de Dados

1. ‚¨ú Script de migra√ß√£o de dados PostgreSQL ‚Üí Oracle
2. ‚¨ú Verificar sincroniza√ß√£o com `VW_USUARIO` (dados v√™m do SGRH)
3. ‚¨ú Verificar sincroniza√ß√£o com `VW_UNIDADE` (dados v√™m do SGRH)
4. ‚¨ú Migrar perfis ADMIN: `usuario_perfil` (WHERE perfil='ADMIN') ‚Üí `ADMINISTRADOR`
5. ‚¨ú Outros perfis n√£o precisam migra√ß√£o (v√™m de `VW_USUARIO_PERFIL`)
6. ‚¨ú Ajustar PKs de `unidade_processo` (remover coluna `codigo`)
7. ‚¨ú Criar registros em `UNIDADE_MAPA`
8. ‚¨ú Validar integridade referencial

---

## 7. RISCOS E DESAFIOS

### 7.1. Alto Risco

1. **Mudan√ßa de UNIDADE e USUARIO para VIEWs externas**
   - Depend√™ncia cr√≠tica de sistema externo (SGRH)
   - Se a VIEW n√£o estiver dispon√≠vel, o sistema para
   - Poss√≠vel desalinhamento de dados

2. **Chave composta em UNIDADE_PROCESSO**
   - JPA com chaves compostas √© mais complexo
   - Todas as queries que usam esta tabela precisam ser reescritas

3. **Invers√£o de relacionamento MAPA ‚Üî SUBPROCESSO**
   - Mudan√ßa conceitual significativa
   - Pode quebrar l√≥gica de neg√≥cio existente

4. **Remo√ß√£o de UsuarioPerfil como tabela f√≠sica**
   - N√£o √© mais gerenciado diretamente pelo SGC
   - Migra√ß√£o para modelo de VIEW consolidada
   - Apenas ADMIN √© gerenciado via tabela `ADMINISTRADOR`

### 7.2. M√©dio Risco

1. **Mudan√ßa de tipos de dados**
   - TIMESTAMP(6) ‚Üí DATE perde precis√£o de **microssegundos** (fra√ß√µes de segundo)
   - Hora/minuto/segundo s√£o **preservados** no DATE do Oracle
   - Boolean ‚Üí String precisa de convers√£o

2. **FKs l√≥gicas sem constraints**
   - Perda de integridade referencial garantida pelo banco
   - Valida√ß√µes precisam ser feitas na aplica√ß√£o

3. **~~Sequences do Oracle~~** (N√£o aplic√°vel - usando IDENTITY nativo)

### 7.3. Baixo Risco

1. **Convers√£o de tipos b√°sicos** (BIGINT ‚Üí NUMBER)
2. **Ajuste de tamanhos de String**
3. **Renomea√ß√£o de campos**

---

## 8. RECOMENDA√á√ïES

### 8.1. Antes de Come√ßar

1. ‚úÖ **DDL das VIEWS j√° dispon√≠vel**
2. ‚¨ú **Validar ambiente:** Permiss√µes nos schemas SRH2 e CORAU
3. ‚¨ú **Entender regras de neg√≥cio das VIEWs:**
   - Como √© calculado o tipo de unidade (OPERACIONAL, INTERMEDIARIA, etc.)?
   - Qual a diferen√ßa entre `unidade_lot_codigo` e `unidade_comp_codigo`?
   - Como funcionam os perfis autom√°ticos GESTOR e CHEFE?
4. ‚¨ú **Decidir sobre o m√≥dulo de Diagn√≥stico (manter ou remover)**

### 8.2. Durante a Migra√ß√£o

1. **Fazer a migra√ß√£o por m√≥dulos/pacotes**
2. **Manter testes sempre funcionando**
3. **Usar feature flags para testar gradualmente**
4. **Documentar todas as decis√µes de design**

### 8.3. Ap√≥s a Migra√ß√£o

1. **Monitorar performance das VIEWs**
2. **Implementar cache para dados de USUARIO e UNIDADE**
3. **Considerar tabela de auditoria para mudan√ßas cr√≠ticas**
4. **Estabelecer plano de rollback**

---

## 10. PR√ìXIMOS PASSOS IMEDIATOS

1. ‚¨ú Come√ßar pela base:
   - Verificar `EntidadeBase` (deve funcionar sem altera√ß√µes)
   - Mapear Unidade e Usuario como VIEWs com `@Immutable`
   - Converter UsuarioPerfil para VIEW com `@Immutable`
   - Criar entidade `Administrador` (tabela f√≠sica)
   - Criar entidades auxiliares (UnidadeMapa)

---

# Decis√µes de Design - Migra√ß√£o do Modelo de Dados SGC

**Data:** 11 de Dezembro de 2024

## üéØ DECIS√ïES CONFIRMADAS

### 1. Gerenciamento de Perfis ADMIN
- ‚úÖ Todos os perfis ADMIN ser√£o gerenciados exclusivamente atrav√©s da tabela f√≠sica `ADMINISTRADOR`
- ‚úÖ Esta √© a √öNICA tabela de perfis gerenciada diretamente pelo SGC
- ‚úÖ Outros perfis (GESTOR, CHEFE, SERVIDOR) s√£o derivados automaticamente pela VIEW `VW_USUARIO_PERFIL_UNIDADE`
- ‚úÖ **A√ß√£o Required:** Criar interface web para adicionar/remover administradores (acesso apenas perfil ADMIN)

**Implementa√ß√£o:**
- Tabela `ADMINISTRADOR` (PK: `usuario_titulo VARCHAR2(12)`)
- Controller `AdministradorController` com endpoints protegidos (`@PreAuthorize("hasRole('ADMIN')")`)
- View Vue `AdministradoresView.vue` para gerenciar
- Service `AdministradorService.ts` para API

---

### 2. M√≥dulo Diagn√≥stico
- ‚úÖ MANTER o m√≥dulo, mas ISOLAR do Oracle
- ‚úÖ Usar H2 in-memory com DataSource separado
- ‚úÖ Tabelas de diagn√≥stico N√ÉO existir√£o no Oracle
- ‚úÖ Configura√ß√£o: m√∫ltiplos DataSources (Oracle principal + H2 diagn√≥stico)

**Implementa√ß√£o:**
- Criar `DataSourceConfig` com 2 datasources:
   - `oracleDataSource` (principal, `@Primary`)
   - `diagnosticoDataSource` (H2 in-memory)
- Criar `diagnosticoEntityManagerFactory` apontando para pacote `sgc.diagnostico.model`
- Criar `diagnosticoTransactionManager`
- Reposit√≥rios de diagn√≥stico usam `@Transactional(transactionManager = "diagnosticoTransactionManager")`
- Schema SQL separado: `schema-diagnostico.sql` (apenas para H2)

**Tabelas H2 (Diagn√≥stico):**
- `DIAGNOSTICO`
- `AVALIACAO_SERVIDOR`
- `OCUPACAO_CRITICA`

---

### 3. FKs L√≥gicas (sem constraints f√≠sicos)
- ‚úÖ Deixar o Hibernate gerenciar (sem valida√ß√£o manual na aplica√ß√£o)
- ‚úÖ Entidades apontando para VIEWs usam FK l√≥gica
- ‚úÖ Valida√ß√µes de integridade ocorrem apenas no c√≥digo quando cr√≠tico

**Impacto:**
- FKs para `VW_UNIDADE` e `VW_USUARIO`: sem constraint f√≠sico no Oracle
- JPA gerencia relacionamentos normalmente com `@ManyToOne` e `@JoinColumn`
- N√£o adicionar valida√ß√µes manuais (confiar no Hibernate)

---

### 4. Unidade SEM_EQUIPE
- ‚úÖ IGNORAR no c√≥digo de neg√≥cio
- ‚úÖ Este tipo √© usado apenas internamente pela VIEW `VW_UNIDADE`
- ‚úÖ Filtrar em queries quando necess√°rio

**Implementa√ß√£o:**
```java
// Enum tem o valor, mas c√≥digo filtra quando necess√°rio
public enum TipoUnidade {
    OPERACIONAL,
    INTERMEDIARIA,
    INTEROPERACIONAL,
    SEM_EQUIPE,  // ‚Üê Ignorar
    RAIZ
}

// Filtrar em queries
public List<Unidade> buscarUnidadesOperacionais() {
    return unidadeRepo.findAll().stream()
        .filter(u -> u.getTipo() != TipoUnidade.SEM_EQUIPE)
        .filter(u -> u.getTipo() != TipoUnidade.RAIZ)
        .collect(Collectors.toList());
}
```

---

### 5. Unidade RAIZ (c√≥digo 1)
- ‚úÖ √â a raiz da hierarquia organizacional
- ‚úÖ Equivalente conceitual √† antiga "SEDOC"
- ‚úÖ Usar como ponto de partida para navega√ß√£o hier√°rquica

**Implementa√ß√£o:**
```java
// Buscar unidade raiz
public Unidade buscarUnidadeRaiz() {
    return unidadeRepo.findById(1L)
        .orElseThrow(() -> new IllegalStateException("Unidade RAIZ n√£o encontrada"));
}

// Usar como raiz da √°rvore hier√°rquica
public List<Unidade> buscarHierarquia() {
    Unidade raiz = buscarUnidadeRaiz();
    return construirArvore(raiz);
}
```

**Valida√ß√£o:**
```sql
SELECT * FROM VW_UNIDADE WHERE codigo = 1 AND tipo = 'RAIZ';
-- Deve retornar exatamente 1 linha
```

---

## üìã RESUMO DAS A√á√ïES NECESS√ÅRIAS

| A√ß√£o | Status | Prioridade |
|------|--------|------------|
| Criar interface web para administradores | ‚¨ú TODO | ALTA |
| Configurar m√∫ltiplos DataSources (Oracle + H2) | ‚¨ú TODO | ALTA |
| Isolar m√≥dulo Diagn√≥stico (H2) | ‚¨ú TODO | M√âDIA |
| Adicionar filtros para SEM_EQUIPE | ‚¨ú TODO | BAIXA |
| Implementar busca de Unidade RAIZ | ‚¨ú TODO | BAIXA |

---

## ‚úÖ PR√ìXIMOS PASSOS

1. **Fase 1-5:** Implementar migra√ß√£o b√°sica (VIEWs, PKs compostas, etc.)
2. **Fase 6:** Implementar m√≥dulo Diagn√≥stico isolado (H2)
3. **Fase 7:** Criar interface de administradores
4. **Fase 8:** Testes completos
5. **Fase 9:** Migra√ß√£o de dados (se necess√°rio)

